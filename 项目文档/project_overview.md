# KeyMouse 项目概述

## 概述

KeyMouse 是一个旨在通过键盘提供对鼠标全面控制的应用程序。它允许用户自定义按键绑定，实现鼠标移动、点击、滚动等操作，并支持多种运行模式（如普通模式、鼠标控制模式、区域选择模式）。该项目致力于提供高效、灵活且用户友好的鼠标替代方案，尤其适用于需要精确控制或不便使用物理鼠标的场景。

## 项目结构

KeyMouse 项目的结构清晰，主要模块各司其职，共同构建了应用程序的完整功能。以下是主要目录和文件的概述：

*   **`main.py`**: 应用程序的主入口点，负责初始化、事件循环、模式管理和核心逻辑的协调。
*   **`gui.py`**: 图形用户界面模块，基于 `tkinter` 构建，提供用户配置和交互界面。
*   **`config_loader.py`**: 配置加载模块，负责从 `config.ini` 文件读取和解析所有应用程序设置。
*   **`modeswitch.py`**: 模式切换管理模块，定义并控制应用程序的不同操作模式（普通、鼠标控制、区域选择）。
*   **`path_manager.py`**: 路径管理模块，提供在不同运行环境下（源代码、打包后）获取应用程序各种路径的实用函数。
*   **`region_selector.py`**: 区域选择器模块，提供一个独立的 GUI 界面，用于用户选择屏幕上的特定区域。
*   **`scroll_controller.py`**: 平滑滚动控制模块，实现鼠标滚动的物理模型和逻辑。
*   **`tray_icon.py`**: 系统托盘图标模块，提供应用程序在系统托盘区的交互功能。
*   **`utool.py`**: 通用工具模块，包含键映射等辅助功能。
*   **`win_platform.py`**: Windows 平台特定功能模块，封装与 Windows API 交互的底层操作，如像素级滚动。
*   **`config.ini`**: 应用程序的配置文件，存储所有用户可配置的设置和键绑定。
*   **`setup.py`**: 用于打包应用程序的脚本（例如使用 cx_Freeze）。
*   **`项目文档/`**: 存放所有模块介绍文档的目录。

## 核心模块及其交互

KeyMouse 的功能通过多个模块的紧密协作来实现：

*   **`main.py`** 作为核心协调者，启动时会加载 **`config_loader.py`** 获取配置，并根据配置初始化 **`modeswitch.py`** 来管理应用程序模式。它还创建 **`MouseControl`** 实例，该实例内部集成了 **`MouseActionManager`** 来处理具体的鼠标操作，并与 **`scroll_controller.py`** 和 **`win_platform.py`** 协同实现平滑滚动。
*   **`pynput`** 库在 **`main.py`** 中用于监听全局键盘事件，并通过 `win32_event_filter` 机制与 **`modeswitch.py`** 交互，实现模式切换和按键事件的分发。
*   **`gui.py`** 提供了用户友好的配置界面，它通过 **`config_loader.py`** 读取和写入配置，并允许用户动态调整各种设置。GUI 模块还可以触发主程序的重启以应用某些设置。
*   **`region_selector.py`** 是一个独立的进程，由 **`main.py`** 在需要时启动。它利用 **`tkinter`** 提供可视化区域选择功能，并将选定的坐标通过文件传递回 **`main.py`**。
*   **`path_manager.py`** 确保了应用程序在不同打包环境下能够正确地找到自身及相关脚本的路径，这对于 `region_selector.py` 作为独立可执行文件运行至关重要。
*   **`tray_icon.py`** 与 **`modeswitch.py`** 紧密集成，通过系统托盘图标直观地显示当前模式，并提供快速切换模式和退出程序的选项。
*   **`utool.py`** 提供了通用的键映射字典，供 `config_loader.py` 和 `main.py` 使用，确保键值的一致性和可维护性。

## 程序运行逻辑

KeyMouse 的运行逻辑可以概括为以下几个阶段：

1.  **启动与初始化**: 
    *   程序从 `main.py` 启动。如果检测到 `--gui` 参数，则启动 GUI 界面 (`gui.py`)。
    *   否则，程序以命令行模式运行，并进行日志配置。
    *   检查并请求管理员权限（如果 `config.ini` 中配置了 `run_as_admin`）。
    *   加载 `config.ini` 中的所有配置到 `AppConfig` 对象。
    *   初始化 `MouseControl` 实例，该实例包含了 `ModeSwitch` 和 `MouseActionManager`。
    *   启动 `pynput` 键盘监听器和鼠标移动工作线程。

2.  **事件处理**: 
    *   键盘监听器 (`pynput.keyboard.Listener`) 捕获全局键盘事件。
    *   `MouseControl` 的 `on_press` 和 `on_release` 方法处理按键事件，包括速度修饰键（Shift, CapsLock）、模式切换热键和程序退出键。
    *   `win32_event_filter` 用于过滤 Windows 消息，实现更底层的热键检测和按键抑制。

3.  **模式切换**: 
    *   `modeswitch.py` 管理应用程序的当前模式。用户可以通过热键或托盘图标在普通模式、鼠标控制模式和区域选择模式之间切换。
    *   在鼠标控制模式下，键盘输入被转换为鼠标移动和点击操作。
    *   进入区域选择模式时，主程序会暂停键盘钩子，并启动独立的 `region_selector.py` 进程。

4.  **鼠标操作**: 
    *   `MouseActionManager` 根据当前模式和激活的按键来执行鼠标移动、点击（包括粘滞点击）和滚动操作。
    *   鼠标移动在一个独立的守护线程中持续进行，确保平滑响应。
    *   平滑滚动由 `scroll_controller.py` 和 `win_platform.py` 协同完成，通过物理模型计算滚动距离并调用底层 Windows API 实现像素级滚动。

5.  **配置管理**: 
    *   用户可以通过 GUI 界面修改配置，这些修改会实时保存到 `config.ini` 文件中。
    *   某些配置更改（如管理员权限设置）可能需要重启程序才能完全生效。

6.  **程序退出**: 
    *   用户可以通过托盘图标、GUI 界面或预设的退出热键来安全退出程序。
    *   退出时，程序会停止所有监听器和线程，并执行必要的清理工作。

## 重难点

KeyMouse 项目在设计和实现过程中面临并解决了以下几个主要挑战：

1.  **底层输入处理与兼容性**: 
    *   **挑战**: 跨应用程序的全局键盘钩子和按键抑制需要与操作系统底层交互，这在不同 Windows 版本和安全策略下可能存在兼容性问题。同时，需要区分物理按键事件和模拟按键事件，避免循环触发。
    *   **解决方案**: 使用 `pynput` 库的 `win32_event_filter` 机制，结合 `win32api` 和 `win32con` 进行更细粒度的控制。通过管理员权限运行程序以获取必要的系统权限。

2.  **平滑滚动实现**: 
    *   **挑战**: 实现像素级的平滑滚动而非传统的行/页滚动，需要精确控制滚轮事件，并模拟物理惯性效果。
    *   **解决方案**: 设计了 `ScrollController` 来模拟物理模型（初速度、最大速度、加速度），并利用 `win_platform.py` 直接调用 Windows API (`SendInput`) 发送像素级滚轮事件，绕过高级库的限制。

3.  **多进程与进程间通信**: 
    *   **挑战**: `region_selector.py` 作为独立的 GUI 进程，需要与主程序进行通信，传递选定的坐标信息。同时，要确保主程序在区域选择期间能够暂停其键盘钩子，避免冲突。
    *   **解决方案**: 主程序通过 `subprocess` 启动 `region_selector.py`，并使用临时文件作为进程间通信的媒介来传递坐标。`modeswitch.py` 负责在进入/退出区域选择模式时暂停/恢复键盘钩子。

4.  **打包与环境兼容性**: 
    *   **挑战**: 应用程序需要能够在源代码环境、PyInstaller 打包和 Nuitka 打包等不同环境下正常运行，并正确找到内部资源和外部脚本（如 `region_selector.py`）。
    *   **解决方案**: `path_manager.py` 模块专门设计用于处理不同运行环境下的路径解析，确保 `sys.executable` 和 `sys.frozen` 等属性的正确使用，以及对 Nuitka 特定打包行为的兼容。

5.  **用户体验与配置灵活性**: 
    *   **挑战**: 提供丰富的自定义选项（键绑定、速度、模式），同时保持界面的直观性和易用性。
    *   **解决方案**: 采用 `tkinter` 构建 GUI，通过 `config.ini` 提供灵活的配置选项。`ScrollableFrame` 等自定义控件提升了界面的可用性。托盘图标和模式切换的视觉反馈增强了用户对程序状态的感知。

6.  **错误处理与日志记录**: 
    *   **挑战**: 确保程序在遇到异常时能够优雅地处理，并提供足够的日志信息以便调试和问题排查。
    *   **解决方案**: 广泛使用 `try-except` 块捕获潜在异常，并利用 `logging` 模块将关键事件和错误信息记录到 `main.log` 文件中，同时在必要时通过 `MessageBox` 向用户显示错误信息。